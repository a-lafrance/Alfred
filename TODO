Input:
- one main grammar for the whole chatbot
- each command contributes to that grammar's syntax and lexicon however it needs to
- use cyk parse to parse input into parse tree
  - if parse fails, return error

Semantics:
- each command is given a chance to interpret the parse tree
  - if successful, that command is executed
  - if all commands fail, return error
- each command has some parameters that it has to fulfill -- extract them from parse tree and exec the command
  - need to find a way to parse non-alphabetical grammar stuff, like commas (for conjunction) and regex (for paths/directories)
- python probably has some way to execute system commands but i forget what it is

Output:
- each command has its own output grammar (distinct from input grammar)
- for error output, just return a generic error message (sample from common error output grammar)
- for command output, sample from that command's output grammar

step 1: fix cyk parse
- literally make the grammar functional and the cyk parse implementation foolproof
  - status: done
- how to parse things that aren't words (like commas and commands)
  - step 1: tokenization
    - status: done
  - step 2: parsing tokens not words
    - status: done
  - step 3: parsing conjunctions
    - status: done

step 2: impl command input
- make command classes and make them able to interpret a parse tree
  - keep a running "remaining lexicon", slim it down at every node in the tree until you can fill out the command
  - commands:
    - ListCommand - DONE
    - MoveCommand - DONE
    - CopyCommand - DONE
    - RemoveCommand - DONE
    - RawCommand - DONE
    - CommandGroup - DONE
  - bot also needs to remember context:
    - the word "there" = last path mentioned
      - ex: "list the contents of `dir`, copy everything from there to `dir2`"
    - the word "that" = result of last command ("it" also counts) _or_ the last command executed
      - ex1: "copy `dir` to `new dir` and move everything in it to `other dir`"
      - ex2: "list everything in `dir`, copy everything in `dir2` to `dir`, then do it again" OR "do that again"

step 3: semantics
- implement command execution (see `subprocess` module)
  - status: DONE
- TODO: set up some kind of test env to actually test semantics fully

step 4: output
- figure out how to sample from a grammar (or just hard code stuff idk)
- print to user

step 5: refine
- add extras
- tighten up the interface
- etc


KNOWN ISSUES:
- double conjunction doesn't work (like comma + conjunction word)
- backticks in command input aren't handled


















OUTPUT GRAMMAR:

S -> Noun Verb | PP Verb
